/*
 * Copyright 2018 by Heiko Sch√§fer <heiko@rangun.de>
 *
 * This file is part of huffman.
 *
 * huffman is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * huffman is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with huffman.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <iostream>
#include <iterator>
#include <fstream>

#include "hufflib.h"

static std::string nodeLabel(const HUFFMAN::TREE * const n) {

	std::ostringstream os, hex, nor;

	if(n->leaf()) {
		hex << "0x" << std::hex << (((uint16_t)n->name()) & 0xff);
		nor << "\'" << (n->name() == '\"' ? "\\\"" : std::string(1, n->name())) << "\'";
		os << " [label=\"" << (std::isprint(n->name()) ? nor.str() : hex.str())
			<< " (" << std::defaultfloat << n->probability()
				<< ")\",shape=ellipse,style=filled,fillcolor=darkolivegreen,fontcolor=beige]";
	} else {
		os << " [label=\"" << std::defaultfloat << n->probability()
			<< "\",shape=box,style=filled,fillcolor=beige,fontcolor=darkolivegreen]";
	}

	return os.str();
}

static void tree2dot(const HUFFMAN::TREE * const n, const std::string &l) {

	if(n->left()) {
		std::cout << "\tN" << std::hex << n->left() << nodeLabel(n->left()) << ";" << std::endl;
		std::cout << "\tN" << std::hex << n << " -> " << "N" << n->left()
			<< "[label=\"" << (l + "0") << "\",fontcolor=red,labeldistance=3];" << std::endl;
		tree2dot(n->left(), l + "0");
	}

	if(n->right()) {
		std::cout << "\tN" << std::hex << n->right() << nodeLabel(n->right()) << ";" << std::endl;
		std::cout << "\tN" << std::hex << n << " -> " << "N" << n->right()
			<< "[label=\"" << (l + "1") << "\",fontcolor=blue,labeldistance=3];" << std::endl;
		tree2dot(n->right(), l + "1");
	}
}

int main(int argc, char **argv) {

	HUFFMAN::ALPHABET alpha;
	HUFFMAN::CSEQ    source;

	{
		std::istream *in;

		const bool isFile(argc == 2 && argv[1][0] != '-');

		if(isFile) {
			in = new std::ifstream(argv[1], std::ios::in|std::ios::binary);
		} else {
			in = &std::cin;
		}

		std::unordered_map<char, std::size_t> m;
		std::size_t ms = 0u;
		char i;

		while(!in->read(&i, 1).eof()) {
			++m[i];

			if(ms < 56u) source.emplace_back(i);

			++ms;
		}

		if(isFile) {
			delete in;
		}

#ifdef HAVE_RATIONAL_H
		const PROBABILITY pf(1ul, ms);
#else
		const PROBABILITY pf(1.0f/ms);
#endif

		for(const auto& mi : m) {
			alpha.emplace_back(HUFFMAN::ALPHABET_ENTRY(mi.first, pf * PROBABILITY(mi.second)));
		}
	}

	const HUFFMAN huff(alpha);
	const bool binary = std::find_if(std::begin(source), std::end(source),
		[](const HUFFMAN::CSEQ::value_type &x) { return !std::isprint(x); }) != std::end(source);

	std::cout << "/* Huffman-tree for: ";

	if(!binary) {
		std::cout << "\"";
		std::copy(std::begin(source), std::end(source),
			std::ostream_iterator<HUFFMAN::character_type>(std::cout));
		std::cout << "\"";
	} else {
		std::cout << "binary input";
	}

	std::cout << " */" << std::endl
		<< "/* Generated by huffdot (" << PACKAGE_STRING << ", " << PACKAGE_URL << ") */"
		<< std::endl << std::endl;
	std::cout << "digraph hufftree {" << std::endl;
	std::cout << "\tfontname=\"Courier\";" << std::endl << "\tfontnames=\"ps\";" << std::endl
		<< "\trank=same;" << std::endl << "\trankdir=RL;" << std::endl << "\tcenter=true;"
		<< std::endl << "\tsplines=false;" << std::endl << "\tlabel=\"Huffman-tree for: ";

	if(!binary) {
		std::cout << "\\\"";
		std::copy(std::begin(source), std::end(source),
			std::ostream_iterator<HUFFMAN::character_type>(std::cout));
		std::cout << "\\\"";
	} else {
		std::cout << "binary input";
	}

	std::cout << (source.size() > 55u ? "..." : "") <<  "\"" << std::endl;
	std::cout << std::endl << "\tN" << std::hex << huff.tree() << nodeLabel(huff.tree()) << ";"
		<< std::endl;
	tree2dot(huff.tree(), "");
	std::cout << "}" << std::endl;

	return EXIT_SUCCESS;
}
